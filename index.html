<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Burmese JSON Concordancer</title>
    <style>
        /* --- Visual Styles --- */
        body { 
            font-family: "Pyidaungsu", "Myanmar3", "Segoe UI", sans-serif; 
            padding: 40px; background-color: #f8f9fa; color: #333;
            max-width: 1400px; /* Wider to fit metadata */
            margin: 0 auto; 
        }

        h1 { text-align: center; color: #2c3e50; margin-bottom: 20px; }

        .controls { 
            background: #ffffff; padding: 20px; border-radius: 12px; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.05); text-align: center; margin-bottom: 30px;
        }
        .input-group { margin: 10px; display: inline-block; vertical-align: bottom; }
        label { font-size: 0.85em; color: #666; display: block; margin-bottom: 5px; text-align: left; font-weight: bold; }
        input[type="text"] { padding: 10px; width: 250px; border: 1px solid #ddd; border-radius: 6px; }
        select { padding: 10px; border-radius: 6px; border: 1px solid #ddd; background: white; }
        
        button { 
            padding: 10px 20px; background-color: #009879; color: white; border: none; 
            border-radius: 6px; cursor: pointer; font-weight: bold; transition: background 0.3s;
        }
        button:hover { background-color: #007f65; }

        /* Tables */
        .section-title { margin-top: 40px; margin-bottom: 10px; font-size: 1.3em; color: #009879; border-bottom: 2px solid #ddd; padding-bottom: 5px; }
        
        table { width: 100%; border-collapse: collapse; background: white; box-shadow: 0 2px 15px rgba(0,0,0,0.05); border-radius: 8px; overflow: hidden; margin-bottom: 20px; table-layout: fixed; }
        th { background-color: #009879; color: #ffffff; padding: 12px; text-align: left; font-size: 0.9em; }
        td { padding: 8px 12px; border-bottom: 1px solid #eee; font-size: 0.95em; word-wrap: break-word; }
        tr:nth-child(even) { background-color: #f9f9f9; }

        /* Concordance Columns - Adjusted for Metadata */
        .col-meta { width: 20%; color: #444; font-size: 0.85em; background: #fafafa; border-right: 1px solid #eee; }
        .col-left { text-align: right; width: 30%; color: #555; }
        .col-kwic { text-align: center; width: 15%; font-weight: bold; color: #d9534f; background: #fff0f0; white-space: nowrap; }
        .col-right { text-align: left; width: 30%; color: #555; }
        
        /* Collocate Table */
        .col-len { width: 15%; font-weight: bold; color: #555; }
        .col-phrase { width: 65%; font-family: "Myanmar3", "Pyidaungsu", sans-serif; }
        .col-count { width: 20%; text-align: right; font-weight: bold; color: #009879; }

        #status { font-weight: 500; margin-bottom: 10px; font-size: 0.9em; }
        .credit { margin-top: 50px; text-align: center; color: #aaa; font-size: 0.8em; }
        .credit a { color: #aaa; text-decoration: none; }
    </style>
</head>
<body>

    <h1>Burmese Lyrics Concordancer</h1>

    <div class="controls">
        <div id="status">Loading corpus.json...</div>
        
        <div class="input-group">
            <label>Search Word</label>
            <input type="text" id="searchInput" placeholder="e.g., အချစ်">
        </div>

        <div class="input-group">
            <label>Concordance Limit</label>
            <select id="limitSelect">
                <option value="20">Show 20</option>
                <option value="50">Show 50</option>
                <option value="all">Show All</option>
            </select>
        </div>

        <button onclick="runSearch()">Search</button>
    </div>

    <!-- MAIN CONCORDANCE TABLE -->
    <div class="section-title">Concordance Lines</div>
    <table id="resultsTable">
        <thead>
            <tr>
                <!-- New Column for Attributes -->
                <th class="col-meta">Source Attributes</th>
                <th class="col-left">Left Context</th>
                <th class="col-kwic">Keyword</th>
                <th class="col-right">Right Context</th>
            </tr>
        </thead>
        <tbody id="resultsBody"></tbody>
    </table>

    <!-- COLLOCATE TABLE -->
    <div class="section-title">Common Phrases (Frequency > 20)</div>
    <table id="collocateTable">
        <thead>
            <tr>
                <th>Pattern Type</th>
                <th>Phrase Found</th>
                <th style="text-align:right">Frequency</th>
            </tr>
        </thead>
        <tbody id="collocateBody"></tbody>
    </table>

    <div class="credit">
        <p>Syllable breaking logic adapted from <a href="https://github.com/ye-kyaw-thu/sylbreak" target="_blank">ye-kyaw-thu/sylbreak</a>.</p>
    </div>

<script>
    // ==========================================
    // DATA CONFIGURATION
    // ==========================================
    let globalCorpus = []; 
    let sourceMap = []; // Maps index ranges to Metadata objects

    // Hardcoded constraints for stability
    const FREQ_THRESHOLD = 20; 
    const MAX_PHRASE_LEN = 3; 

    // 1. Load JSON Corpus
    fetch('corpus.json')
        .then(response => response.json())
        .then(jsonData => {
            let currentIndex = 0;
            
            // Iterate over every song/entry in the JSON
            jsonData.forEach(entry => {
                // Assume entry.text contains the syllable broken string
                // Clean newlines just in case
                let cleanText = entry.text.replace(/[\r\n]+/g, ' ');
                let tokens = cleanText.split(/\s+/).filter(t => t.length > 0);
                
                // Record the range for this specific song
                let start = currentIndex;
                let end = currentIndex + tokens.length - 1;
                
                sourceMap.push({
                    start: start,
                    end: end,
                    meta: entry // Store the whole object (title, artist, etc)
                });

                // Add to the master search array
                globalCorpus = globalCorpus.concat(tokens);
                currentIndex += tokens.length;

                // Add a "Wall" so searches don't bleed from Song A into Song B
                globalCorpus.push("###EOF###");
                currentIndex++;
            });

            document.getElementById('status').innerText = `Loaded ${sourceMap.length} documents (${globalCorpus.length.toLocaleString()} syllables).`;
            document.getElementById('status').style.color = "green";
        })
        .catch(err => {
            console.error(err);
            document.getElementById('status').innerText = "Error loading 'corpus.json'. Check format.";
            document.getElementById('status').style.color = "red";
        });

    // 2. HELPER: Format Metadata for Display
    // CHANGE THIS FUNCTION to match your JSON keys!
    function getMetaString(metaObj) {
        // Example: returns "Song Title (Artist)"
        // If your JSON has "year", you can add that too.
        let title = metaObj.title || "Unknown Title";
        let artist = metaObj.artist ? ` (${metaObj.artist})` : "";
        return `<strong>${title}</strong>${artist}`;
    }

    // 3. HELPER: Syllable Breaker (for search input)
    function sylBreak(text) {
        const myanmarConsonant = "[\u1000-\u1021]";
        let re = new RegExp("((?<!^|\\s)" + myanmarConsonant + "(?![\\u1037\\u1039\\u103A]))", "g");
        let broken = text.replace(re, " $1");
        return broken.replace(/\s+/g, ' ').trim();
    }

    // 4. HELPER: Find Metadata by Index
    function getSourceInfo(index) {
        // Simple loop to find which song range this index falls into
        for(let item of sourceMap) {
            if(index >= item.start && index <= item.end) {
                return getMetaString(item.meta);
            }
        }
        return "Unknown Source";
    }

    // 5. MAIN SEARCH LOGIC
    function runSearch() {
        const rawInput = document.getElementById('searchInput').value.trim();
        const limitStr = document.getElementById('limitSelect').value;
        const conTbody = document.getElementById('resultsBody');
        const colTbody = document.getElementById('collocateBody');
        
        conTbody.innerHTML = "";
        colTbody.innerHTML = "";

        if(!rawInput) return;
        document.getElementById('status').innerText = "Searching...";

        setTimeout(() => {
            const processedQuery = sylBreak(rawInput);
            const queryTokens = processedQuery.split(" ");
            const firstToken = queryTokens[0];
            const qLen = queryTokens.length;

            // --- Step A: Find Matches ---
            let matches = [];

            for (let i = 0; i < globalCorpus.length; i++) {
                if (globalCorpus[i] === firstToken) {
                    let isMatch = true;
                    for(let j = 0; j < qLen; j++) {
                        if(globalCorpus[i + j] !== queryTokens[j]) {
                            isMatch = false; break;
                        }
                    }

                    if (isMatch) {
                        // Identify Source
                        let metaHtml = getSourceInfo(i);

                        // Context
                        let startLeft = Math.max(0, i - 10);
                        let leftCtx = globalCorpus.slice(startLeft, i).join(" ");
                        let endRight = Math.min(globalCorpus.length, i + qLen + 10);
                        let rightCtx = globalCorpus.slice(i + qLen, endRight).join(" ");

                        // Raw tokens for stats
                        let rawLeft = globalCorpus.slice(Math.max(0, i - MAX_PHRASE_LEN), i);
                        let rawRight = globalCorpus.slice(i + qLen, Math.min(globalCorpus.length, i + qLen + MAX_PHRASE_LEN));

                        matches.push({
                            meta: metaHtml,
                            left: leftCtx,
                            keyword: processedQuery,
                            right: rightCtx,
                            rawLeft: rawLeft,
                            rawRight: rawRight
                        });
                    }
                }
            }

            document.getElementById('status').innerText = `Found ${matches.length} hits. Rendering...`;

            // --- Step B: Render Concordance ---
            let displayCount = (limitStr === 'all') ? matches.length : parseInt(limitStr);
            let displayMatches = matches.slice(0, Math.min(matches.length, displayCount));
            
            let conRows = "";
            displayMatches.forEach(m => {
                conRows += `<tr>
                    <td class="col-meta">${m.meta}</td>
                    <td class="col-left">${m.left}</td>
                    <td class="col-kwic">${m.keyword}</td>
                    <td class="col-right">${m.right}</td>
                </tr>`;
            });
            if(matches.length === 0) conRows = `<tr><td colspan="4" style="text-align:center">No matches found.</td></tr>`;
            conTbody.innerHTML = conRows;

            // --- Step C: Collocate Analysis (Optimized) ---
            let patternCounts = {};

            matches.forEach(m => {
                // Right Side
                for (let len = 1; len <= MAX_PHRASE_LEN; len++) {
                    if (m.rawRight.length >= len) {
                        let sub = m.rawRight.slice(0, len).join(" ");
                        if(sub.includes("###EOF###")) continue;
                        let key = `Right +${len}||` + processedQuery + " " + sub;
                        patternCounts[key] = (patternCounts[key] || 0) + 1;
                    }
                }
                // Left Side
                for (let len = 1; len <= MAX_PHRASE_LEN; len++) {
                    if (m.rawLeft.length >= len) {
                        let sub = m.rawLeft.slice(m.rawLeft.length - len).join(" ");
                        if(sub.includes("###EOF###")) continue;
                        let key = `Left +${len}||` + sub + " " + processedQuery;
                        patternCounts[key] = (patternCounts[key] || 0) + 1;
                    }
                }
            });

            // Sort & Filter
            let sorted = [];
            for (let key in patternCounts) {
                if (patternCounts[key] >= FREQ_THRESHOLD) {
                    let parts = key.split("||");
                    sorted.push({ type: parts[0], phrase: parts[1], count: patternCounts[key] });
                }
            }
            sorted.sort((a, b) => b.count - a.count);

            // Render Collocates
            let colRows = "";
            if (sorted.length === 0) {
                colRows = `<tr><td colspan="3" style="text-align:center">No patterns found > ${FREQ_THRESHOLD} times.</td></tr>`;
            } else {
                sorted.forEach(p => {
                    colRows += `<tr>
                        <td class="col-len">${p.type}</td>
                        <td class="col-phrase">${p.phrase}</td>
                        <td class="col-count">${p.count}</td>
                    </tr>`;
                });
            }
            colTbody.innerHTML = colRows;
            document.getElementById('status').innerText = `Done. Found ${matches.length} hits.`;

        }, 50);
    }
</script>

</body>
</html>
