<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Burmese Song Lyrics Corpus Concordance</title>
    <style>
        /* --- Modern & Clean Visuals --- */
        body { 
            font-family: "Pyidaungsu", "Myanmar3", "Segoe UI", sans-serif; 
            padding: 40px; 
            background-color: #f8f9fa; 
            color: #333;
            max-width: 1200px; 
            margin: 0 auto; 
        }

        h1 { text-align: center; color: #2c3e50; margin-bottom: 30px; }

        /* Search Box Area */
        .controls { 
            background: #ffffff; padding: 25px; border-radius: 12px; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.05); text-align: center; margin-bottom: 30px;
        }

        .input-group { margin: 10px; display: inline-block; vertical-align: top; }
        label { font-size: 0.85em; color: #666; display: block; margin-bottom: 5px; text-align: left; font-weight: bold; }

        input[type="text"] { 
            padding: 12px; width: 300px; border: 1px solid #ddd; border-radius: 6px; font-size: 16px; 
        }

        select { padding: 12px; border-radius: 6px; border: 1px solid #ddd; background: white; }

        .static-info {
            padding: 12px; background: #e9ecef; border-radius: 6px; color: #555; font-size: 14px; display: inline-block;
        }

        button { 
            padding: 12px 25px; background-color: #009879; color: white; border: none; 
            border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 16px; 
            transition: background 0.3s; margin-top: 22px; /* Align with inputs */
        }
        button:hover { background-color: #007f65; }

        /* Sections */
        .section-title {
            margin-top: 40px; margin-bottom: 15px; font-size: 1.4em; color: #009879; border-bottom: 2px solid #ddd; padding-bottom: 10px;
        }

        /* Tables */
        table { width: 100%; border-collapse: collapse; background: white; box-shadow: 0 2px 15px rgba(0,0,0,0.05); border-radius: 8px; overflow: hidden; margin-bottom: 20px; table-layout: fixed; }
        th { background-color: #009879; color: #ffffff; padding: 15px; text-align: left; font-size: 0.9em; }
        td { padding: 10px 15px; border-bottom: 1px solid #eee; line-height: 1.6; word-wrap: break-word; }
        tr:nth-child(even) { background-color: #f9f9f9; }

        /* Concordance Specifics */
        .left-ctx { text-align: right; width: 40%; color: #555; }
        .keyword { text-align: center; width: 20%; font-weight: bold; color: #d9534f; background: #fff0f0; white-space: nowrap; }
        .right-ctx { text-align: left; width: 40%; color: #555; }
        .count-badge { font-size: 0.8em; background: #6c757d; color: white; padding: 2px 6px; border-radius: 4px; margin-left: 5px; white-space: nowrap; display: inline-block;}

        /* Collocate Specifics */
        .col-len { width: 15%; font-weight: bold; color: #555; }
        .col-phrase { width: 65%; font-family: "Myanmar3", "Pyidaungsu", sans-serif; }
        .col-count { width: 20%; text-align: right; font-weight: bold; color: #009879; }

        #status { font-weight: 500; margin-bottom: 10px; }
        .credit { margin-top: 50px; text-align: center; color: #aaa; font-size: 0.9em; }
        .credit a { color: #aaa; text-decoration: none; }
    </style>
</head>
<body>

    <h1> မြန်မာသီချင်းစာသား စကားလုံး ရှာစက် Burmese Song Lyrics Concordancer</h1>

    <div class="controls">
        <div id="status">Loading corpus.txt...</div>
        
        <div class="input-group">
            <label>ရှာလိုသည့် စကားလုံး</label>
            <input type="text" id="searchInput" placeholder="e.g., အချစ်">
        </div>

        <div class="input-group">
            <label>ပြသရန် စာကြောင်းအရေအတွက်</label>
            <select id="limitSelect">
                <option value="20">၂၀ ကြည့်မည်</option>
                <option value="50">၅၀ ကြည့်မည်</option>
                <option value="all">အကုန်ကြည့်မည် (စက်လေးတတ်သည်)</option>
            </select>
        </div>

        <!-- Fixed settings to prevent crashing -->
        <div class="input-group">
            <label>စကားစု အရေအတွက်</label>
            <div class="static-info">ဝဲယာ သုံးလုံးအထိပြမည်။ အနည်းဆုံး ကြိမ်ရေ ၂၀။​ </div>
        </div>

        <button onclick="runSearch()">ရှာမည်။</button>
    </div>

    <!-- 1. Concordance Section -->
    <div class="section-title"> ရှာသည့်စကားလုံးပါ စာကြောင်းများ (KWIC)</div>
    <table id="resultsTable">
        <thead>
            <tr>
                <th style="text-align:right; width:40%;">ဝဲဘက်မှ စကားလုံးများ </th>
                <th style="text-align:center; width:20%;"> ဦးတည် စကားလုံး </th>
                <th style="text-align:left; width:40%;">ယာဘက်မှ စကားလုံးများ</th>
            </tr>
        </thead>
        <tbody id="resultsBody"></tbody>
    </table>

    <!-- 2. Collocates Section -->
    <div class="section-title"> အသုံးကြိမ်ရေမြင့် စကားစုများ</div>
    <p style="font-size:0.9em; color:#666;"> အောက်တွင်ပြသည့်စကားစုများမှာ  <strong> အကြိမ် ၂၀ </strong> နှင့်အထက် တွေ့ရသည့် ဝဲယာ စကားလုံး သုံးလုံးအထိ ပါသည့် စကားစုများကို ပြထားခြင်းဖြစ်သည်။ </p>
    
    <table id="collocateTable">
        <thead>
            <tr>
                <th>စကားစုတည်ဆောက်ပုံ </th>
                <th>တွေ့ရသည့် စကားစု</th>
                <th style="text-align:right">အကြိမ်ရေ</th>
            </tr>
        </thead>
        <tbody id="collocateBody"></tbody>
    </table>

    <div class="credit">
        <p>Syllable ခွဲသည့်ကုတ်ကို ဆရာရဲကျော်သူ၏ <a href="https://github.com/ye-kyaw-thu/sylbreak" target="_blank">ye-kyaw-thu/sylbreak</a> မှ ရယူထားပါသည်။</p>
    </div>

<script>
    let corpusData = []; 
    // Hardcoded constraints to prevent crashing
    const FREQ_THRESHOLD = 20; 
    const MAX_PHRASE_LEN = 3; 

    // 1. Load Corpus
    fetch('corpus.txt')
        .then(response => response.text())
        .then(text => {
            let cleanText = text.replace(/[\r\n]+/g, ' '); 
            corpusData = cleanText.split(/\s+/); 
            document.getElementById('status').innerText = "Corpus loaded (" + corpusData.length.toLocaleString() + " syllables).";
            document.getElementById('status').style.color = "green";
        })
        .catch(err => {
            document.getElementById('status').innerText = "Error loading corpus.txt";
            document.getElementById('status').style.color = "red";
        });

    // 2. Syllable Breaker
    function sylBreak(text) {
        const myanmarConsonant = "[\u1000-\u1021]";
        let re = new RegExp("((?<!^|\\s)" + myanmarConsonant + "(?![\\u1037\\u1039\\u103A]))", "g");
        let broken = text.replace(re, " $1");
        return broken.replace(/\s+/g, ' ').trim();
    }

    // 3. Search Logic
    function runSearch() {
        const rawInput = document.getElementById('searchInput').value.trim();
        const limitStr = document.getElementById('limitSelect').value;
        
        const conTbody = document.getElementById('resultsBody');
        const colTbody = document.getElementById('collocateBody');
        conTbody.innerHTML = "";
        colTbody.innerHTML = "";

        if(!rawInput) return;

        document.getElementById('status').innerText = "Processing...";

        // Use setTimeout to allow UI to update before heavy processing
        setTimeout(() => {
            // Process Query
            const processedQuery = sylBreak(rawInput);
            const queryTokens = processedQuery.split(" ");
            const firstToken = queryTokens[0];
            const queryLen = queryTokens.length;

            // --- Step A: Find matches ---
            let rawMatches = [];

            for (let i = 0; i < corpusData.length; i++) {
                if (corpusData[i] === firstToken) {
                    let isMatch = true;
                    for(let j = 0; j < queryLen; j++) {
                        if(corpusData[i + j] !== queryTokens[j]) {
                            isMatch = false; break;
                        }
                    }

                    if (isMatch) {
                        // Extract Tokens (10 for display, but we only calculate stats on 3)
                        let startLeft = Math.max(0, i - 10);
                        let leftTokens = corpusData.slice(startLeft, i);
                        
                        let endRight = Math.min(corpusData.length, i + queryLen + 10);
                        let rightTokens = corpusData.slice(i + queryLen, endRight);

                        rawMatches.push({
                            leftToks: leftTokens,
                            rightToks: rightTokens
                        });
                    }
                }
            }

            document.getElementById('status').innerText = `Found ${rawMatches.length} raw hits. Formatting...`;

            // --- Step B: Concordance Display (Deduplicated) ---
            let groupedConcordance = {};
            
            rawMatches.forEach(m => {
                let lStr = m.leftToks.join(" ");
                let rStr = m.rightToks.join(" ");
                let uniqueKey = lStr + "|||" + rStr;
                if (!groupedConcordance[uniqueKey]) {
                    groupedConcordance[uniqueKey] = { left: lStr, right: rStr, count: 0 };
                }
                groupedConcordance[uniqueKey].count++;
            });

            let uniqueMatches = Object.values(groupedConcordance);
            
            // Render Concordance
            let displayCount = uniqueMatches.length;
            if (limitStr !== 'all') displayCount = Math.min(uniqueMatches.length, parseInt(limitStr));

            let conRows = "";
            for (let k = 0; k < displayCount; k++) {
                let item = uniqueMatches[k];
                let countBadge = item.count > 1 ? `<span class="count-badge">(${item.count} times)</span>` : "";
                
                conRows += `<tr>
                    <td class="left-ctx">${item.left}</td>
                    <td class="keyword">${processedQuery}</td>
                    <td class="right-ctx">${item.right} ${countBadge}</td>
                </tr>`;
            }
            if(uniqueMatches.length === 0) conRows = `<tr><td colspan="3" style="text-align:center">No matches found.</td></tr>`;
            conTbody.innerHTML = conRows;

            // --- Step C: Optimized Collocate Analysis ---
            // Only look up to MAX_PHRASE_LEN (3)
            // Filter < FREQ_THRESHOLD (20)

            let patternCounts = {}; 

            rawMatches.forEach(m => {
                // 1. Right Side (1 to 3 words)
                for (let len = 1; len <= MAX_PHRASE_LEN; len++) {
                    if (m.rightToks.length >= len) {
                        let subPhrase = m.rightToks.slice(0, len).join(" ");
                        let key = `Right +${len}||` + processedQuery + " " + subPhrase;
                        patternCounts[key] = (patternCounts[key] || 0) + 1;
                    }
                }

                // 2. Left Side (1 to 3 words)
                for (let len = 1; len <= MAX_PHRASE_LEN; len++) {
                    if (m.leftToks.length >= len) {
                        // Get last 'len' tokens
                        let subPhrase = m.leftToks.slice(m.leftToks.length - len).join(" ");
                        let key = `Left +${len}||` + subPhrase + " " + processedQuery;
                        patternCounts[key] = (patternCounts[key] || 0) + 1;
                    }
                }
            });

            // Convert to array and Filter
            let sortedPatterns = [];
            for (let key in patternCounts) {
                if (patternCounts[key] >= FREQ_THRESHOLD) {
                    let parts = key.split("||");
                    sortedPatterns.push({
                        type: parts[0],
                        phrase: parts[1],
                        count: patternCounts[key]
                    });
                }
            }

            // Sort purely by Frequency (Descending)
            sortedPatterns.sort((a, b) => b.count - a.count);

            // Render Collocates
            let colRows = "";
            if (sortedPatterns.length === 0) {
                colRows = `<tr><td colspan="3" style="text-align:center">No patterns found repeating ${FREQ_THRESHOLD} times or more.</td></tr>`;
            } else {
                sortedPatterns.forEach(p => {
                    colRows += `<tr>
                        <td class="col-len">${p.type}</td>
                        <td class="col-phrase">${p.phrase}</td>
                        <td class="col-count">${p.count}</td>
                    </tr>`;
                });
            }
            colTbody.innerHTML = colRows;
            
            document.getElementById('status').innerText = `Done. Found ${rawMatches.length} raw hits.`;
            
        }, 50); // Small delay to prevent UI freeze
    }
</script>

</body>
</html>
