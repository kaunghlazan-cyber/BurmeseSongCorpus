<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Burmese Lyrics Concordancer (Diagnostic)</title>
    <!-- 1. Force Load Burmese Font -->
    <link href="https://fonts.googleapis.com/css2?family=Padauk:wght@400;700&family=Pyidaungsu&display=swap" rel="stylesheet">
    
    <style>
        /* --- Visual Styles --- */
        body { 
            font-family: "Padauk", "Pyidaungsu", "Myanmar3", sans-serif; /* Priority to Padauk */
            padding: 40px; background-color: #f8f9fa; color: #333;
            max-width: 1400px; margin: 0 auto; 
        }

        h1 { text-align: center; color: #2c3e50; margin-bottom: 20px; }

        /* DEBUG BOX STYLE */
        #debugBox {
            background: #e7f5ff; border: 2px solid #004085; color: #004085;
            padding: 15px; margin-bottom: 20px; border-radius: 8px;
            font-family: monospace; font-size: 14px; white-space: pre-wrap;
        }

        .controls { 
            background: #ffffff; padding: 20px; border-radius: 12px; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.05); text-align: center; margin-bottom: 30px;
        }
        .input-group { margin: 10px; display: inline-block; vertical-align: bottom; }
        label { font-size: 0.85em; color: #666; display: block; margin-bottom: 5px; text-align: left; font-weight: bold; }
        input[type="text"] { padding: 10px; width: 250px; border: 1px solid #ddd; border-radius: 6px; font-family: "Padauk", sans-serif; }
        select { padding: 10px; border-radius: 6px; border: 1px solid #ddd; background: white; }
        
        button { 
            padding: 10px 20px; background-color: #009879; color: white; border: none; 
            border-radius: 6px; cursor: pointer; font-weight: bold; transition: background 0.3s;
        }
        button:hover { background-color: #007f65; }

        /* Tables */
        .section-title { margin-top: 40px; margin-bottom: 10px; font-size: 1.3em; color: #009879; border-bottom: 2px solid #ddd; padding-bottom: 5px; }
        table { width: 100%; border-collapse: collapse; background: white; box-shadow: 0 2px 15px rgba(0,0,0,0.05); border-radius: 8px; overflow: hidden; margin-bottom: 20px; table-layout: fixed; }
        th { background-color: #009879; color: #ffffff; padding: 12px; text-align: left; font-size: 0.9em; }
        td { padding: 8px 12px; border-bottom: 1px solid #eee; font-size: 1em; word-wrap: break-word; vertical-align: middle; }
        tr:nth-child(even) { background-color: #f9f9f9; }

        /* Columns */
        .col-meta { width: 22%; color: #444; font-size: 0.9em; background: #fafafa; border-right: 1px solid #eee; line-height: 1.5em; }
        .col-left { text-align: right; width: 29%; color: #555; }
        .col-kwic { text-align: center; width: 15%; font-weight: bold; color: #d9534f; background: #fff0f0; white-space: nowrap; }
        .col-right { text-align: left; width: 29%; color: #555; }
        
        /* Badges */
        .meta-tag { display: block; margin-top: 2px; color: #666; font-size: 0.95em; }
        .meta-icon { opacity: 0.6; margin-right: 4px; }

        #status { font-weight: 500; margin-bottom: 10px; font-size: 0.9em; }
        .credit { margin-top: 50px; text-align: center; color: #aaa; font-size: 0.8em; }
        .credit a { color: #aaa; text-decoration: none; }
    </style>
</head>
<body>

    <h1>Burmese Lyrics Concordancer</h1>

    <!-- DEBUG BOX to see what's wrong -->
    <div id="debugBox">Initializing Diagnostics...</div>

    <div class="controls">
        <div id="status">Loading corpus.json...</div>
        
        <div class="input-group">
            <label>Search Word</label>
            <input type="text" id="searchInput" placeholder="e.g., á€¡á€á€»á€…á€º">
        </div>

        <div class="input-group">
            <label>Concordance Limit</label>
            <select id="limitSelect">
                <option value="20">Show 20</option>
                <option value="50">Show 50</option>
                <option value="all">Show All</option>
            </select>
        </div>

        <button onclick="runSearch()">Search</button>
    </div> 

    <!-- MAIN CONCORDANCE TABLE -->
    <div class="section-title">Concordance Lines</div>
    <table id="resultsTable">
        <thead>
            <tr>
                <th class="col-meta">Song Details</th>
                <th class="col-left">Left Context</th>
                <th class="col-kwic">Keyword</th>
                <th class="col-right">Right Context</th>
            </tr>
        </thead>
        <tbody id="resultsBody"></tbody>
    </table>

    <!-- COLLOCATE TABLE -->
    <div class="section-title">Common Phrases (Frequency > 20)</div>
    <table id="collocateTable">
        <thead>
            <tr>
                <th style="width:15%">Pattern Type</th>
                <th style="width:65%">Phrase Found</th>
                <th style="width:20%; text-align:right">Frequency</th>
            </tr>
        </thead>
        <tbody id="collocateBody"></tbody>
    </table>

    <div class="credit">
        <p>Syllable breaking logic adapted from <a href="https://github.com/ye-kyaw-thu/sylbreak" target="_blank">ye-kyaw-thu/sylbreak</a>.</p>
    </div>

<script>
    let globalCorpus = []; 
    let sourceMap = []; 
    const FREQ_THRESHOLD = 20; 
    const MAX_PHRASE_LEN = 3; 

    // --- AUTOMATIC KEY DETECTOR ---
    // This will hold the "real" names of your keys (e.g., "SongTitle" instead of "title")
    let detectedKeys = {
        title: null,
        vocalist: null,
        composer: null,
        lyrics: null
    };

    function logDebug(msg) {
        document.getElementById('debugBox').innerText += "\n" + msg;
    }

    // 1. Load JSON Corpus
    fetch('corpus.json')
        .then(response => response.json())
        .then(jsonData => {
            
            if (!Array.isArray(jsonData) || jsonData.length === 0) {
                logDebug("ERROR: JSON is not an array or is empty.");
                return;
            }

            // --- DIAGNOSTICS: INSPECT FIRST ITEM ---
            let first = jsonData[0];
            let flatKeys = Object.keys(first);
            let metaKeys = [];
            
            // Check if metadata is nested
            let metaObject = first; 
            if (first.metadata) { metaObject = first.metadata; metaKeys = Object.keys(first.metadata); }
            else if (first.meta) { metaObject = first.meta; metaKeys = Object.keys(first.meta); }
            
            logDebug("File Loaded. Checking structure...");
            logDebug("Root Keys found: " + flatKeys.join(", "));
            if(metaKeys.length > 0) logDebug("Metadata Keys found: " + metaKeys.join(", "));

            // --- SMART KEY MAPPING ---
            // Helper to find case-insensitive partial match
            function findKey(obj, searchTerms) {
                let keys = Object.keys(obj);
                for (let k of keys) {
                    let kLower = k.toLowerCase();
                    for (let term of searchTerms) {
                        if (kLower.includes(term)) return k;
                    }
                }
                return null;
            }

            // 1. Find Lyrics (Longest Text Field)
            let maxLen = 0;
            for (let k of flatKeys) {
                if (typeof first[k] === 'string' && first[k].length > maxLen) {
                    maxLen = first[k].length;
                    detectedKeys.lyrics = k;
                }
            }

            // 2. Find Metadata (Search in metaObject)
            detectedKeys.title = findKey(metaObject, ["title", "song", "name", "track"]);
            detectedKeys.vocalist = findKey(metaObject, ["voc", "sing", "artist", "performer"]);
            detectedKeys.composer = findKey(metaObject, ["comp", "writ", "author"]);

            logDebug("--- AUTO-DETECTED MAPPING ---");
            logDebug(`Lyrics Field   : ${detectedKeys.lyrics}`);
            logDebug(`Title Field    : ${detectedKeys.title}`);
            logDebug(`Vocalist Field : ${detectedKeys.vocalist}`);
            logDebug(`Composer Field : ${detectedKeys.composer}`);

            // PROCESS DATA
            let currentIndex = 0;
            
            jsonData.forEach(entry => {
                let rawText = entry[detectedKeys.lyrics] || "";
                
                if (rawText) {
                    let cleanText = rawText.replace(/[\r\n]+/g, ' ');
                    let tokens = cleanText.split(/\s+/).filter(t => t.length > 0);
                    
                    let start = currentIndex;
                    let end = currentIndex + tokens.length - 1;
                    
                    // Determine where metadata lives for this entry
                    let metaSource = entry;
                    if(entry.metadata) metaSource = entry.metadata;
                    else if(entry.meta) metaSource = entry.meta;

                    sourceMap.push({
                        start: start,
                        end: end,
                        meta: metaSource 
                    });

                    globalCorpus = globalCorpus.concat(tokens);
                    currentIndex += tokens.length;
                    globalCorpus.push("###EOF###");
                    currentIndex++;
                }
            });

            document.getElementById('status').innerText = `Loaded ${sourceMap.length} songs. Ready.`;
            document.getElementById('status').style.color = "green";
        })
        .catch(err => {
            logDebug("CRITICAL ERROR: " + err.message);
        });

    // 2. Display Metadata using Detected Keys
    function getMetaString(metaObj) {
        let title = "Unknown Title";
        let voc = "Unknown";
        let comp = "Unknown";

        if(detectedKeys.title && metaObj[detectedKeys.title]) title = metaObj[detectedKeys.title];
        if(detectedKeys.vocalist && metaObj[detectedKeys.vocalist]) voc = metaObj[detectedKeys.vocalist];
        if(detectedKeys.composer && metaObj[detectedKeys.composer]) comp = metaObj[detectedKeys.composer];
        
        return `
            <strong style="color:#009879; font-size:1.1em;">${title}</strong>
            <span class="meta-tag"><span class="meta-icon">ðŸŽ¤</span> ${voc}</span>
            <span class="meta-tag"><span class="meta-icon">ðŸŽ¼</span> ${comp}</span>
        `;
    }

    // 3. Syllable Breaker
    function sylBreak(text) {
        const myanmarConsonant = "[\u1000-\u1021]";
        let re = new RegExp("((?<!^|\\s)" + myanmarConsonant + "(?![\\u1037\\u1039\\u103A]))", "g");
        let broken = text.replace(re, " $1");
        return broken.replace(/\s+/g, ' ').trim();
    }

    // 4. Find Metadata by Index
    function getSourceInfo(index) {
        for(let item of sourceMap) {
            if(index >= item.start && index <= item.end) {
                return getMetaString(item.meta);
            }
        }
        return "Unknown Source";
    }

    // 5. Search Logic
    function runSearch() {
        const rawInput = document.getElementById('searchInput').value.trim();
        const limitStr = document.getElementById('limitSelect').value;
        const conTbody = document.getElementById('resultsBody');
        const colTbody = document.getElementById('collocateBody');
        
        conTbody.innerHTML = "";
        colTbody.innerHTML = "";

        if(!rawInput) return;
        document.getElementById('status').innerText = "Searching...";

        setTimeout(() => {
            const processedQuery = sylBreak(rawInput);
            const queryTokens = processedQuery.split(" ");
            const firstToken = queryTokens[0];
            const qLen = queryTokens.length;

            let matches = [];

            for (let i = 0; i < globalCorpus.length; i++) {
                if (globalCorpus[i] === firstToken) {
                    let isMatch = true;
                    for(let j = 0; j < qLen; j++) {
                        if(globalCorpus[i + j] !== queryTokens[j]) {
                            isMatch = false; break;
                        }
                    }

                    if (isMatch) {
                        let metaHtml = getSourceInfo(i);
                        let startLeft = Math.max(0, i - 10);
                        let leftCtx = globalCorpus.slice(startLeft, i).join(" ");
                        let endRight = Math.min(globalCorpus.length, i + qLen + 10);
                        let rightCtx = globalCorpus.slice(i + qLen, endRight).join(" ");
                        let rawLeft = globalCorpus.slice(Math.max(0, i - MAX_PHRASE_LEN), i);
                        let rawRight = globalCorpus.slice(i + qLen, Math.min(globalCorpus.length, i + qLen + MAX_PHRASE_LEN));

                        matches.push({
                            meta: metaHtml,
                            left: leftCtx,
                            keyword: processedQuery,
                            right: rightCtx,
                            rawLeft: rawLeft,
                            rawRight: rawRight
                        });
                    }
                }
            }

            document.getElementById('status').innerText = `Found ${matches.length} hits.`;

            let displayCount = (limitStr === 'all') ? matches.length : parseInt(limitStr);
            let displayMatches = matches.slice(0, Math.min(matches.length, displayCount));
            
            let conRows = "";
            displayMatches.forEach(m => {
                conRows += `<tr>
                    <td class="col-meta">${m.meta}</td>
                    <td class="col-left">${m.left}</td>
                    <td class="col-kwic">${m.keyword}</td>
                    <td class="col-right">${m.right}</td>
                </tr>`;
            });
            if(matches.length === 0) conRows = `<tr><td colspan="4" style="text-align:center">No matches found.</td></tr>`;
            conTbody.innerHTML = conRows;

            let patternCounts = {};
            matches.forEach(m => {
                for (let len = 1; len <= MAX_PHRASE_LEN; len++) {
                    if (m.rawRight.length >= len) {
                        let sub = m.rawRight.slice(0, len).join(" ");
                        if(sub.includes("###EOF###")) continue;
                        let key = `Right +${len}||` + processedQuery + " " + sub;
                        patternCounts[key] = (patternCounts[key] || 0) + 1;
                    }
                }
                for (let len = 1; len <= MAX_PHRASE_LEN; len++) {
                    if (m.rawLeft.length >= len) {
                        let sub = m.rawLeft.slice(m.rawLeft.length - len).join(" ");
                        if(sub.includes("###EOF###")) continue;
                        let key = `Left +${len}||` + sub + " " + processedQuery;
                        patternCounts[key] = (patternCounts[key] || 0) + 1;
                    }
                }
            });

            let sorted = [];
            for (let key in patternCounts) {
                if (patternCounts[key] >= FREQ_THRESHOLD) {
                    let parts = key.split("||");
                    sorted.push({ type: parts[0], phrase: parts[1], count: patternCounts[key] });
                }
            }
            sorted.sort((a, b) => b.count - a.count);

            let colRows = "";
            if (sorted.length === 0) {
                colRows = `<tr><td colspan="3" style="text-align:center">No patterns found > ${FREQ_THRESHOLD} times.</td></tr>`;
            } else {
                sorted.forEach(p => {
                    colRows += `<tr>
                        <td class="col-len">${p.type}</td>
                        <td class="col-phrase">${p.phrase}</td>
                        <td class="col-count">${p.count}</td>
                    </tr>`;
                });
            }
            colTbody.innerHTML = colRows;

        }, 50);
    }
</script>
</body>
</html>
